// import PptxGenJS from "/jianying-srt/bundle/vendors/pptxgen/pptxgen.es.js";
// also depend on sweetalert 2
const primaryElement = document.getElementById("input-text");
const defaultSecondaryElement = document.getElementById("output-temp");
const backgroundImageElement = document.getElementById("uploadBackgroundImage");
const backgroundColorElement = document.getElementById("colorPickerBackground");
const primaryFormElement = document.getElementById("primarySettings");
const secondaryFormElement = document.getElementById("secondarySettings");
const advancedPrimaryOptionElement = document.getElementById(
  "txt-advanced-primary-options"
);
const advancedSecondaryOptionElement = document.getElementById(
  "txt-advanced-secondary-options"
);
const DEFAULT_BACKGROUND_COLOR = "000000";
const DEFAULT_FONT_COLOR = "FFFFFF";
const DEFAULT_AUTHOR = "Howard Lim";
const DEFAULT_SUBJECT = "Lyrics Presentation - Generated by PPT Generator";
const DEFAULT_TITLE = "PPT Generator Presentation";
const DEFAULT_PPT_LAYOUT = "LAYOUT_16x9";
const DEFAULT_LINE_COUNT_PER_ROW = 2;
const LYRIC_POSITION = {
  COVER: "cover",
  UPPER: "upper",
  LOWER: "lower",
};
const LYRIC_TYPE = {
  PRIMARY: "primary",
  SECONDARY: "secondary",
};

const DEFAULT_BASE_OPTION = {
  x: "0%",
  w: "100%",
  bold: true,
  color: DEFAULT_FONT_COLOR,
  fontFace: "Microsoft Yahei",
  fontSize: "50",
  align: "center",
  isTextBox: true,
};

const DEFAULT_OPTION = {
  NORMAL: {
    PRIMARY: {
      x: "0%",
      y: {
        upper: "26%",
        lower: "56%",
      },
      cover: {
        y: "30%",
        fontSize: "80",
        fontFace: "Microsoft Yahei",
      },
      bold: true,
      color: "FFFFFF",
      fontFace: "Microsoft Yahei",
      fontSize: "60",
      charSpacing: "2",
      shadow: {
        type: "outer",
        color: "000000",
        blur: "3",
        offset: "3",
        angle: "45",
        opacity: "0.5",
      },
    },
    SECONDARY: {
      x: "0%",
      y: {
        upper: "39%",
        lower: "69%",
      },
      cover: {
        y: "50%",
        fontSize: "48",
        fontFace: "Microsoft Yahei",
      },
      bold: true,
      color: "FFFFFF",
      fontFace: "Microsoft Yahei",
      fontSize: "31",
      charSpacing: "0",
      shadow: {
        type: "outer",
        color: "000000",
        blur: "3",
        offset: "3",
        angle: "45",
        opacity: "0.5",
      },
    },
  },
  LIVE: {
    PRIMARY: {
      x: "0%",
      y: {
        upper: "84%",
        lower: "55%",
      },
      cover: {
        y: "84%",
        fontSize: "34",
        fontFace: "Microsoft Yahei",
      },
      bold: true,
      color: "FFFFFF",
      fontFace: "Microsoft Yahei",
      fontSize: "30",
      charSpacing: "2",
      shadow: {
        type: "outer",
        color: "000000",
        blur: "3",
        offset: "3",
        angle: "45",
        opacity: "0.5",
      },
    },
    SECONDARY: {
      x: "0%",
      y: {
        upper: "92%",
        lower: "65%",
      },
      cover: {
        y: "92%",
        fontSize: "20",
        fontFace: "Segoe Print",
      },
      bold: true,
      color: "FFFFFF",
      fontFace: "Microsoft Yahei",
      fontSize: "18",
      charSpacing: "0",
      shadow: {
        type: "outer",
        color: "000000",
        blur: "3",
        offset: "3",
        angle: "45",
        opacity: "0.5",
      },
    },
  },
};

async function getFileFromUrl(url, fileName = "file") {
  try {
    const response = await fetch(url);
    const data = await response.blob();
    return Promise.resolve(new File([data], fileName));
  } catch (e) {
    return Promise.resolve(null);
  }
}

function readSettingsFile(file) {
  var fileReader = new FileReader();
  fileReader.onload = function (event) {
    let importedSettings;
    try {
      importedSettings = JSON.parse(event.target.result);
    } catch (error) {
      console.log(err);
      alert("Error in compiling imported option, please check your file");
      return;
    }

    if (
      !importedSettings?.advancedPrimaryOption ||
      !importedSettings?.advancedSecondaryOption
    ) {
      alert("Invalid settings");
      return;
    }
    alert("Setting Applied Successfully");

    setAdvancedSettings(
      importedSettings?.advancedPrimaryOption,
      importedSettings?.advancedSecondaryOption
    );

    populateSettings(
      importedSettings?.advancedPrimaryOption,
      importedSettings?.advancedSecondaryOption
    );
    // reset back to empty, else cannot uploading same file cannot trigger on change
    document.querySelector("#uploadSetting").value = "";
  };
  fileReader.readAsText(file);
  fileReader = null;
}

async function readSettingsFileFromURL(url) {
  const settingFile = await getFileFromUrl(url, `setting-file`);
  if (!settingFile) {
    return alert("Invalid settings option");
  }
  readSettingsFile(settingFile);
}

async function onGeneratePptClick() {
  // Swal.fire({
  //   title: "Please Wait...",
  //   html: "Generating PPT...",
  //   didOpen: () => {
  //     Swal.showLoading();
  //   },
  // });
  if (!IsUiOptionTallyWithAdvancedOption()) {
    const result = await Swal.fire({
      title: "参数不一致",
      html: "<p>设定(4)与高级设定(6)的参数不一致，<br/>需要应用最新的设定(4)吗？</p><br/><small>注：如选择不应用，生成PPT时将以高级设定(6)为准</small>",
      icon: "question",
      showDenyButton: true,
      showCancelButton: true,
      confirmButtonText: "应用",
      denyButtonText: "不应用",
      cancelButtonText: "取消生成",
    });

    if (result.isDismissed) {
      return;
    }
    if (result.isConfirmed) {
      onApplySettingsClick();
    }
    if (result.isDenied) {
      Swal.fire("此生成将使用高级设定的参数", "", "info");
    }
  }

  const hasSecondaryContent = !document.getElementById(
    "chbHasIgnoreSecondaryContent"
  ).checked;
  const isOneLinePerSlide = document.getElementById(
    "chbIsOneLinePerSlide"
  ).checked;
  const isBackgroundColorWhenEmpty = document.getElementById(
    "chbIsBackgroundColorWhenEmpty"
  ).checked;

  generateFullPpt({
    hasSecondaryContent: hasSecondaryContent,
    linePerSlide: isOneLinePerSlide ? 1 : DEFAULT_LINE_COUNT_PER_ROW,
    isBackgroundColorWhenEmpty,
  });
}

function IsUiOptionTallyWithAdvancedOption() {
  let formData = new FormData(primaryFormElement);
  const primaryOption = getUiOption(formData);
  formData = new FormData(secondaryFormElement);
  const secondaryOption = getUiOption(formData);
  const advancedPrimaryOption = GetCustomPrimaryOption();
  const advancedSecondaryOption = GetCustomSecondaryOption();

  return (
    JSON.stringify(primaryOption) === JSON.stringify(advancedPrimaryOption) &&
    JSON.stringify(secondaryOption) === JSON.stringify(advancedSecondaryOption)
  );
}

// to convert file to data url
function getBase64(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.readAsDataURL(file);
    reader.onload = () => resolve(reader.result);
    reader.onerror = (error) => reject(error);
  });
}

// this function requires pptxgen library imported at the first place
async function generateFullPpt({
  hasSecondaryContent = true,
  linePerSlide,
  isBackgroundColorWhenEmpty,
}) {
  const linePerRow = linePerSlide;
  let coverCount = 0;
  let sectionCount = 0;

  const primaryLyric = primaryElement.value;
  const secondaryLyric = document.getElementById("outputPinyin")
    ? document.getElementById("outputPinyin").value
    : defaultSecondaryElement.value;

  const primaryLinesArray = primaryLyric.split("\n");
  const secondaryLinesArray = secondaryLyric.split("\n");

  if (
    hasSecondaryContent &&
    primaryLinesArray.length !== secondaryLinesArray.length &&
    !confirm(
      `主内容有 ${primaryLinesArray.length} 行，而副内容有 ${secondaryLinesArray.length} 行，确定继续吗？`
    )
  ) {
    return;
  }

  // 1. Create a new Presentation
  let pres = new PptxGenJS();
  pres.author = DEFAULT_AUTHOR;
  pres.subject = DEFAULT_SUBJECT;
  pres.title = DEFAULT_TITLE;
  pres.layout = DEFAULT_PPT_LAYOUT;

  // 2. Create Slides Master with Background
  const backgroundProp = await GetPptBackgroundProp();

  pres.defineSlideMaster({
    title: "MASTER_SLIDE_BACKGROUND_IMAGE",
    background: backgroundProp,
  });
  pres.defineSlideMaster({
    title: "MASTER_SLIDE_BACKGROUND_COLOR",
    background: { color: backgroundProp.color },
  });

  // 3.0 Get Options
  const customPrimaryOption = GetCustomPrimaryOption();
  const customSecondaryOption = GetCustomSecondaryOption();

  let currentSection = "";
  // 3. Create Slides
  primaryLinesArray.forEach((primaryLine, index) => {
    const isCover = primaryLine.startsWith("# ");
    const isSectionLine = primaryLine.startsWith("--- ");

    if (isSectionLine) {
      sectionCount++;
      const sectionName = primaryLine.replace("--- ", "");
      currentSection = sectionName;
      pres.addSection({ title: sectionName });
      return;
    }

    let currentLine = primaryLine;
    const currentIndex = index - coverCount - sectionCount;

    if (isCover) {
      coverCount++;
      const regex = /^#[^#]*/;
      currentLine = currentLine.match(regex)[0].replace("# ", "").trim();
    }

    const isEmptyLine = currentLine.trim().length == 0;

    let slide = GetWorkingSlide({
      pres,
      currentIndex,
      linePerRow,
      isCover,
      isEmptyLine,
      isBackgroundColorWhenEmpty,
      ...(currentSection && { currentSection }),
    });

    const currentLyricPosition = isCover
      ? LYRIC_POSITION.COVER
      : currentIndex % linePerRow == 0
      ? LYRIC_POSITION.UPPER
      : LYRIC_POSITION.LOWER;

    // add primary content
    AddTextLineToSlide({
      slide,
      line: currentLine,
      type: LYRIC_TYPE.PRIMARY,
      lyricPosition: currentLyricPosition,
      primaryOption: customPrimaryOption,
      secondaryOption: customSecondaryOption,
    });

    if (hasSecondaryContent) {
      //add secondary content
      let secondaryLine = secondaryLinesArray[index] ?? "";
      if (isCover) {
        secondaryLine = secondaryLine.replace("# ", "");

        const subCoverLineIndex = secondaryLine.indexOf("## ");
        const hasSubCoverLine = subCoverLineIndex != -1;

        if (hasSubCoverLine) {
          secondaryLine = secondaryLine.substring(subCoverLineIndex + 3);
        }
      }

      AddTextLineToSlide({
        slide,
        line: secondaryLine,
        type: LYRIC_TYPE.SECONDARY,
        lyricPosition: currentLyricPosition,
        primaryOption: customPrimaryOption,
        secondaryOption: customSecondaryOption,
      });
    }
  });

  //   4. Save the Presentation
  pres.writeFile({ fileName: "Sample Presentation.pptx" });
}

async function GetPptBackgroundProp() {
  const backgroundProp = {
    color: backgroundColorElement?.value ?? DEFAULT_BACKGROUND_COLOR,
  };
  return backgroundImageElement.value !== ""
    ? {
        ...backgroundProp,
        data: await getBase64(backgroundImageElement.files[0]),
      }
    : backgroundProp;
}

function GetCustomPrimaryOption() {
  let option;
  try {
    option = JSON.parse(advancedPrimaryOptionElement.value);
  } catch (err) {
    console.log(err);
    alert(
      "Error in compiling Primary Advanced Option, please check your input"
    );
    return;
  }
  return option;
}

function GetCustomSecondaryOption() {
  let option;
  try {
    option = JSON.parse(advancedSecondaryOptionElement.value);
  } catch (err) {
    console.log(err);
    alert(
      "Error in compiling Secondary Advanced Option, please check your input"
    );
    return;
  }
  return option;
}

function GetWorkingSlide({
  pres,
  currentIndex,
  linePerRow,
  isCover,
  currentSection,
  isEmptyLine,
  isBackgroundColorWhenEmpty,
}) {
  const remainder = currentIndex % linePerRow; //create new slide if remainder is 0
  const isUseBackgroundColor = isEmptyLine && isBackgroundColorWhenEmpty;
  if (remainder === 0 || isCover) {
    return pres.addSlide({
      masterName: isUseBackgroundColor
        ? "MASTER_SLIDE_BACKGROUND_COLOR"
        : "MASTER_SLIDE_BACKGROUND_IMAGE",
      ...(currentSection && { sectionTitle: currentSection }),
    });
  }
  const slidesCount = pres.slides.length;
  return pres.getSlide(slidesCount);
}

function AddTextLineToSlide({
  slide,
  line,
  type = LYRIC_TYPE.PRIMARY,
  lyricPosition = LYRIC_POSITION.UPPER,
  primaryOption,
  secondaryOption,
}) {
  const isUpper = lyricPosition == LYRIC_POSITION.UPPER;
  const isCover = lyricPosition == LYRIC_POSITION.COVER;
  const isTypePrimary = type == LYRIC_TYPE.PRIMARY;
  const isTypeSecondary = type == LYRIC_TYPE.SECONDARY;
  let customOption = isTypePrimary ? primaryOption : secondaryOption;
  let customValues = {};

  customValues = {
    y: isUpper ? customOption.y?.upper : customOption.y?.lower,
  };

  if (isCover) {
    customValues = {
      ...customValues,
      ...(customOption.cover || {}),
    };
  }

  customOption = {
    ...customOption,
    ...customValues,
  };
  const finalOption = { ...DEFAULT_BASE_OPTION, ...customOption };
  // had to do like below because somehow the shadow value cannot be parsed correctly

  slide.addText(line, {
    ...finalOption,
    shadow: {
      ...(finalOption.shadow ?? null),
      type: "outer",
      blur: finalOption.shadow?.blur ?? 3,
      offset: finalOption.shadow?.offset ?? 3,
      angle: finalOption.shadow?.angle ?? 45,
      opacity: finalOption.shadow?.opacity ?? 0.5,
    },
  });
}

function onRestoreNormalDefaultOptionClick() {
  setAdvancedSettings(
    DEFAULT_OPTION.NORMAL.PRIMARY,
    DEFAULT_OPTION.NORMAL.SECONDARY
  );
  populateSettings(
    DEFAULT_OPTION.NORMAL.PRIMARY,
    DEFAULT_OPTION.NORMAL.SECONDARY
  );
}

function onRestoreGreenScreenDefaultOptionClick() {
  setAdvancedSettings(
    DEFAULT_OPTION.LIVE.PRIMARY,
    DEFAULT_OPTION.LIVE.SECONDARY
  );
  populateSettings(DEFAULT_OPTION.LIVE.PRIMARY, DEFAULT_OPTION.LIVE.SECONDARY);
}

function setAdvancedSettings(primaryOption, secondaryOption) {
  advancedPrimaryOptionElement.value = JSON.stringify(primaryOption, null, 4);
  advancedSecondaryOptionElement.value = JSON.stringify(
    secondaryOption,
    null,
    4
  );
}

function updateLineNumber(textarea, indicator) {
  indicator.innerText = textarea.value
    .substr(0, textarea.selectionStart)
    .split("\n").length;
}

function onExportSettingClick() {
  let primaryOption, secondaryOption;
  try {
    primaryOption = JSON.parse(advancedPrimaryOptionElement.value);
    secondaryOption = JSON.parse(advancedSecondaryOptionElement.value);
  } catch (err) {
    console.log(err);
    alert(
      "Error in compiling Primary Advanced Option, please check your input"
    );
    return;
  }

  const blob = new Blob(
    [
      JSON.stringify({
        advancedPrimaryOption: primaryOption,
        advancedSecondaryOption: secondaryOption,
      }),
    ],
    {
      type: "application/octet-stream",
    }
  );
  const blobUrl = URL.createObjectURL(blob);

  // Create a link element
  const link = document.createElement("a");

  // Set link's href to point to the Blob URL
  link.href = blobUrl;
  link.download = `PptGeneratorSetting-${Date.now()}.json`;

  // Append link to the body
  document.body.appendChild(link);

  // Dispatch click event on the link
  // This is necessary as link.click() does not work on the latest firefox
  link.dispatchEvent(
    new MouseEvent("click", {
      bubbles: true,
      cancelable: true,
      view: window,
    })
  );

  // Remove link from body
  document.body.removeChild(link);
}

function populateFontFaceList({
  dataListId = "fontFaces",
  filePath = "/assets/data/fontFaceList.csv",
}) {
  const host = self.location.host;
  let endpoint = host;
  if (host === "localhost:8080") {
    endpoint = `${self.location.host}/${self.location.pathname.split("/")[1]}`; //for dev purpose
  }

  var requestURL = `${self.location.protocol}//${endpoint}${filePath}`;
  var xhr = new XMLHttpRequest();
  xhr.onreadystatechange = process;
  xhr.open("GET", requestURL, false);
  xhr.send();

  function process() {
    if (xhr.readyState == 4) {
      const dataListElement = document.querySelector(`#${dataListId}`);
      const fontFaces = xhr.responseText.split(",");

      fontFaces.forEach(function (item) {
        var option = document.createElement("option");
        option.value = item;
        dataListElement.appendChild(option);
      });
    }
  }
}

function initializeSettings() {
  const customPrimaryOption = GetCustomPrimaryOption();
  const customSecondaryOption = GetCustomSecondaryOption();
  populateSettings(customPrimaryOption, customSecondaryOption);
}

function populateSettings(primaryOption, secondaryOption) {
  for (let index = 0; index < 2; index++) {
    const formElement = index === 0 ? primaryFormElement : secondaryFormElement;
    const option = index === 0 ? primaryOption : secondaryOption;
    formElement.querySelector("input[name='x']").value = option.x?.replace(
      "%",
      ""
    );
    formElement.querySelector("input[name='y-upper']").value =
      option.y?.upper?.replace("%", "");
    formElement.querySelector("input[name='y-lower']").value =
      option.y?.lower?.replace("%", "");
    formElement.querySelector("input[name='bold']").checked = option.bold;
    formElement.querySelector("input[name='color']").value =
      "#" + option.color ?? "FFFFFF";
    formElement.querySelector("input[name='fontFace']").value = option.fontFace;
    formElement.querySelector("input[name='fontSize']").value = option.fontSize;
    formElement.querySelector("input[name='charSpacing']").value =
      option.charSpacing;

    formElement.querySelector("input[name='cover-y']").value =
      option.cover?.y?.replace("%", "");
    formElement.querySelector("input[name='cover-fontFace']").value =
      option.cover?.fontFace || "";
    formElement.querySelector("input[name='cover-fontSize']").value =
      option.cover?.fontSize;

    formElement.querySelector("input[name='hasGlow']").checked = option.glow;
    formElement.querySelector("input[name='glow-size']").value =
      option.glow?.size;
    formElement.querySelector("input[name='glow-color']").value =
      "#" + (option.glow?.color ?? "000000");

    formElement.querySelector("input[name='hasOutline']").checked =
      option.outline;
    formElement.querySelector("input[name='outline-size']").value =
      option.outline?.size;
    formElement.querySelector("input[name='outline-color']").value =
      "#" + (option.outline?.color ?? "000000");

    formElement.querySelector("input[name='hasShadow']").checked =
      option.shadow;
    formElement.querySelector("select[name='shadow-type']").value =
      option.shadow?.type;
    formElement.querySelector("input[name='shadow-color']").value =
      "#" + (option.shadow?.color ?? "000000");
    formElement.querySelector("input[name='shadow-blur']").value =
      option.shadow?.blur;
    formElement.querySelector("input[name='shadow-offset']").value =
      option.shadow?.offset;
    formElement.querySelector("input[name='shadow-angle']").value =
      option.shadow?.angle;
    formElement.querySelector("input[name='shadow-opacity']").value =
      option.shadow?.opacity;
  }
}

async function onApplySettingsClick() {
  let formData = new FormData(primaryFormElement);
  const primaryOption = getUiOption(formData);
  formData = new FormData(secondaryFormElement);
  const secondaryOption = getUiOption(formData);

  setAdvancedSettings(primaryOption, secondaryOption);
  await Swal.fire("成功应用设定", "", "success");
}

function getUiOption(formData) {
  let option = {
    x: `${formData.get("x")}%`,
    y: {
      upper: `${formData.get("y-upper")}%`,
      lower: `${formData.get("y-lower")}%`,
    },
    cover: {
      y: `${formData.get("cover-y")}%`,
      fontSize: formData.get("cover-fontSize") ?? "50",
      fontFace: formData.get("cover-fontFace") ?? "Microsoft Yahei",
    },
    bold: !!formData.get("bold"),
    color: formData.get("color")?.replace("#", "") ?? "FFFFFF",
    fontFace: formData.get("fontFace") ?? "Microsoft Yahei",
    fontSize: formData.get("fontSize") ?? 50,
    charSpacing: formData.get("charSpacing") ?? 2,
  };
  if (formData.get("hasGlow")) {
    option = {
      ...option,
      glow: {
        size: formData.get("glow-size") ?? 5,
        color: formData.get("glow-color")?.replace("#", "") ?? "FFFFFF",
      },
    };
  }
  if (formData.get("hasOutline")) {
    option = {
      ...option,
      outline: {
        size: formData.get("outline-size") ?? 1,
        color: formData.get("outline-color")?.replace("#", "") ?? "FFFFFF",
      },
    };
  }
  if (formData.get("hasShadow")) {
    option = {
      ...option,
      shadow: {
        type: formData.get("shadow-type") ?? "outer",
        color: formData.get("shadow-color")?.replace("#", "") ?? "000000",
        blur: formData.get("shadow-blur") ?? 3,
        offset: formData.get("shadow-offset") ?? 3,
        angle: formData.get("shadow-angle") ?? 45,
        opacity: formData.get("shadow-opacity") ?? "0.5",
      },
    };
  }
  return option;
}

(function () {
  var uploadElement = document.querySelector("#uploadSetting");

  uploadElement.addEventListener("change", function (event) {
    const fileExtension = event.target.value.split(".").pop();
    if (fileExtension !== "json") {
      alert("Invalid settings file");
      return;
    }
    readSettingsFile(event.target.files[0]);
  });
})();

//set default settings
$(document).ready(function () {
  onRestoreNormalDefaultOptionClick();
  populateFontFaceList({
    dataListId: "fontFaces",
    filePath: "/assets/data/fontFaceList.csv",
  });
  initializeSettings();
});
